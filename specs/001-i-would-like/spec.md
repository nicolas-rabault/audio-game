# Feature Specification: Self-Contained Character Management System

**Feature Branch**: `001-i-would-like`
**Created**: 2025-10-15
**Status**: Draft
**Input**: User description: "I would like to create a more self contained character management that would allow me to load specific bank of characters. To be able to do that I need to rework how characters informations are stored. I need all informations and functions to be stored in 1 file with a defined format allowing the services (LLM and TTS) to get the information they need to work. I would like to convert all existing characters and move there self-contained file in the story_characters folder. I don't need retro-compatibility with the actual system."

## Clarifications

### Session 2025-10-15

- Q: Character name uniqueness strategy when two files declare the same name? → A: Reject duplicate names entirely with error log - first file wins
- Q: Which character fields are required vs optional for validation? → A: All fields required including metadata (strict validation). Additionally, prompt generation class and functions must be inside the character file
- Q: Character file format for executable prompt generation logic? → A: Python files (.py) with structured docstring/comments for metadata
- Q: What observability metrics are required for character loading? → A: Track character load count, errors, and load time (minimal essential metrics)

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Character Bank Loading (Priority: P1)

As a system administrator, I want to load a specific bank of characters from a designated folder so that I can organize characters by story, campaign, or use case without mixing unrelated character sets.

**Why this priority**: This is the core capability that enables the entire feature. Without the ability to load character banks, the self-contained format provides no practical value.

**Independent Test**: Create a `story_characters/` folder with at least 2 character files. Start the system and verify that only characters from that folder are available for voice selection, not characters from any legacy `voices.yaml` file.

**Acceptance Scenarios**:

1. **Given** a `story_characters/` folder exists with 3 character files, **When** the system starts, **Then** exactly 3 characters are available for selection
2. **Given** the `story_characters/` folder is empty, **When** the system starts, **Then** no characters are loaded and the system logs an appropriate warning
3. **Given** multiple character files in `story_characters/`, **When** a user requests the character list via API, **Then** all characters from that folder are returned with their names and metadata

---

### User Story 2 - Self-Contained Character Files (Priority: P1)

As a character designer, I want each character's complete definition (name, voice sample reference, LLM instructions, and metadata) stored in a single file so that I can manage, share, and version control characters independently without splitting information across multiple systems.

**Why this priority**: This is equally critical as P1 - it defines the fundamental data structure that makes character management self-contained. Without this, characters cannot be truly portable or independently manageable.

**Independent Test**: Create a single character file with all required fields (name, voice path, instructions, metadata). Load this character into the system and verify that both LLM and TTS services can successfully use the character without requiring any external configuration files.

**Acceptance Scenarios**:

1. **Given** a character file with all required fields (name, voice reference, LLM instructions, metadata, prompt generation logic), **When** the system loads the character, **Then** the LLM service receives the correct system prompt generated by the character's own logic and the TTS service receives the correct voice path
2. **Given** a character file with prompt generation functions, **When** the character is loaded, **Then** the system can generate prompts without referencing external instruction classes
3. **Given** a character file is missing any required field (name, voice, instructions, metadata, or prompt generation logic), **When** the system attempts to load it, **Then** the file is rejected with a descriptive error message logged specifying which required field is missing

---

### User Story 3 - Legacy Character Migration (Priority: P2)

As a system maintainer, I want to convert all existing characters from `voices.yaml` into the new self-contained format so that I can preserve existing character configurations while migrating to the new system.

**Why this priority**: This enables smooth transition to the new system without losing existing work. It's P2 because the system can function without legacy characters, but it's important for practical deployment.

**Independent Test**: Run the migration script on the current `voices.yaml` file. Verify that each entry in `voices.yaml` produces exactly one character file in `story_characters/` with all original data preserved (name, voice source, instructions).

**Acceptance Scenarios**:

1. **Given** a `voices.yaml` file with 10 character entries, **When** the migration script runs, **Then** 10 character files are created in `story_characters/`
2. **Given** a character in `voices.yaml` with `type: smalltalk` instructions, **When** migrated, **Then** the new character file contains equivalent instructions that produce the same LLM system prompt
3. **Given** a character in `voices.yaml` with Freesound voice source metadata, **When** migrated, **Then** the new file preserves the source URL, license, and description fields
4. **Given** migrated character files exist in `story_characters/`, **When** loaded by the system, **Then** they function identically to their original `voices.yaml` counterparts

---

### Edge Cases

- What happens when a character file has malformed syntax (invalid Python or missing required metadata)?
  - System should log the specific error and filename, skip that character, and continue loading other valid characters
- What happens when two character files have the same name?
  - System should reject the duplicate name with an error log - first loaded file wins, subsequent files with the same name are skipped
- What happens when a character's voice file path is invalid or missing?
  - System should load the character with a warning, allowing LLM functionality but marking the character as "voice unavailable" for TTS
- What happens when `story_characters/` folder doesn't exist?
  - System should create the folder automatically on startup and log an informational message
- What happens when a character file contains unknown/future fields?
  - System should preserve unknown fields in memory (forward compatibility) but not fail loading

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST load all character definitions from a single designated folder (`story_characters/`) on startup
- **FR-002**: System MUST support a self-contained file format where each character is defined in exactly one file
- **FR-003**: Character files MUST include all required fields: character name, voice sample reference (path), LLM instruction configuration, metadata (comments, quality flags, source attribution), and prompt generation logic (class/functions)
- **FR-003a**: Character files MUST contain prompt generation class and functions within the file - no external dependencies for system prompt generation
- **FR-004**: System MUST provide all necessary information to the LLM service (system prompt generation) from a single character file
- **FR-005**: System MUST provide all necessary information to the TTS service (voice path/reference) from a single character file
- **FR-006**: System MUST NOT require backward compatibility with the existing `voices.yaml` format for character loading
- **FR-007**: System MUST provide a migration utility to convert existing `voices.yaml` entries into individual character files
- **FR-008**: Migration utility MUST preserve all existing character data: name, voice source metadata, instruction types, and custom prompt text
- **FR-009**: System MUST skip invalid or malformed character files with descriptive error logging rather than failing to start
- **FR-014**: System MUST enforce unique character names - if duplicate names are detected, the first loaded file wins and subsequent duplicates are rejected with error logging
- **FR-010**: Character files MUST use Python (.py) format to support executable prompt generation logic, with structured docstrings or comments for metadata that services can parse reliably
- **FR-011**: System MUST support all existing instruction types (constant, smalltalk, quiz_show, news, guess_animal, unmute_explanation) in the new format
- **FR-012**: Character files MUST support both file-based and Freesound-based voice sources with complete attribution metadata
- **FR-013**: System MUST expose loaded characters via the existing API endpoint (`/v1/voices`) without breaking the API contract
- **FR-015**: System MUST emit Prometheus metrics for character loading operations including: total characters loaded (counter), character load errors by type (counter), and character loading duration (histogram)

### Key Entities

- **Character**: Complete definition of a conversational agent
  - Name: Display name for the character (must be unique across all loaded characters) - REQUIRED
  - Voice Source: Reference to audio sample (file path or external source with metadata) - REQUIRED
  - Instructions: Configuration for LLM behavior (instruction type, custom text, language preference) - REQUIRED
  - Metadata: Character attribution (comments, quality flags, source attribution) - REQUIRED
  - Prompt Generation Logic: Class or functions that generate system prompts from instructions - REQUIRED

- **Instruction Configuration**: Specification of LLM behavior
  - Type: One of: constant, smalltalk, quiz_show, news, guess_animal, unmute_explanation
  - Custom Text: Instruction-specific parameters (e.g., constant text, language code)
  - System Prompt: Generated by character's own prompt generation logic (not external classes)

- **Voice Source**: Reference to audio for TTS voice cloning
  - Source Type: Either "file" (local/server path) or "freesound" (external download)
  - Path/URL: Location of audio sample
  - Attribution: License, author, description, links (for external sources)

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: System can load 50+ character files from `story_characters/` folder in under 5 seconds on standard hardware
- **SC-002**: Each character file is independently manageable - adding, removing, or modifying one character file does not affect other characters
- **SC-003**: Migration script successfully converts 100% of valid entries from existing `voices.yaml` with zero data loss
- **SC-004**: Character files can be copied to different environments (dev, staging, prod) and work immediately without additional configuration
- **SC-005**: Developers can create a new character by writing a single file without modifying any code or central configuration
- **SC-006**: System startup completes successfully even when 20% of character files contain errors (graceful degradation)

## Assumptions

- Character files will use Python (.py) format to support executable prompt generation logic
- The `story_characters/` folder will be at the repository root, alongside the current `voices.yaml`
- Character files will be named using the pattern `{character_name}.py` with lowercase, hyphen-separated names
- Voice file paths in character files are relative to the voice storage location (maintaining existing path conventions)
- The existing `/v1/voices` API endpoint structure will not change - only the backend data source changes
- Performance requirement: Loading 100 characters should complete in under 10 seconds
- Each character file should be under 10KB to ensure fast file I/O

## Dependencies & Constraints

### Dependencies

- Existing services (LLM, STT, TTS) remain unchanged per constitution principle I (Service Isolation)
- Voice audio files remain in their current storage locations - only metadata moves to character files
- Pydantic models for data validation (`VoiceSample`, `Instructions` subclasses)

### Constraints

- MUST NOT modify TTS, LLM, or STT services (constitution: Service Isolation)
- MUST maintain existing API contracts for `/v1/voices` endpoint
- Character loading MUST NOT introduce blocking I/O that violates async-first architecture
- File format MUST be human-readable and editable (Python source code with structured metadata, not binary)
- Migration MUST be a one-time operation, not a runtime conversion layer
- MUST emit Prometheus metrics for observability per constitution Principle V (character load count, errors, duration)

## Out of Scope

- Automatic voice file migration (voice audio files stay in current locations)
- Dynamic character bank switching during runtime (system must restart to load different character banks)
- Character validation UI or editor tools
- Character versioning or history tracking
- Multi-folder character loading (single `story_characters/` folder only)
- Backward compatibility mode or dual-loading of `voices.yaml` + character files
